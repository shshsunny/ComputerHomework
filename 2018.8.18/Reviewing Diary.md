# 动态规划及01背包问题 复习日志
本篇日志复习解决动态规划问题的基本过程，以01背包问题作为例子。
- 自顶向下
- 自底向上
- 时间／空间复杂度降维（优化）

**重写原Python程序的C++代码[在这里](https://github.com/shshsunny/ComputerHomework/tree/master/2018.8.18/Cpp%20rewrites)**
## 01：状态转移方程
动态规划都要考虑到**状态转移方程**，也就是将问题分解成一个或者多个子问题的规则。状态转移方程不一定只有一条。

**01背包问题内容**
有一个容量为C的背包，和i件物品，第i件物品占用的大小和它的价值分别为w[i]、v[i]，求出一个解决方案，并得到背包能够装下物品的最大价值总和。

**列出状态转移方程**
依据此思路，定义函数`f(C, i)`，即**求前i件物品能装进背包的最大价值总和**。
01背包问题，也就是每件物品只有装进背包或者不装进背包两种选择。因此，将问题分解为两种不同状态的子问题，再求出它们的最优解（最大值）即可。得到状态转移方程：
`f(C, i) = max(f(C, i - 1), f(C - w[i], i - 1) + v[i])`

## 02：Top-down解决方案
Top-down（自顶向下），**从最大的问题开始逐步分解成小问题**的解决方案。

**直接写出递归解**
基本上，在状态转移方程基础上写好basecase条件判断，就能得到完整的递归解；但是，最难的是basecase的写法。

```py
def f(C, i):
    if i < 0 or C < 0:
        return 0
    return max(f(C, i - 1), f(C - w[i], i - 1) + v[i])
```
这个写法有误，因为并没有检查两个子问题的参数是否是正确的，这会导致计算问题。
添加判断：
```py
def f(C, i):
    if i < 0 or C < 0:
        return 0
    if C >= s[i]: return max(f(C, i - 1), f(C - w[i], i - 1) + v[i])
    else: return f(C, i - 1)
```

或者换成另一种结构，如下：

```py
def f(C, i):
    if i > 0:
        if w[i] > C:
            result = f(C, i - 1)
        else:
            result = max(f(C, i - 1), f(C - w[i], i - 1) + v[i])
    else:
        if w[i] > C:
            result = 0
        else:
            result = v[i]
    return result
```

**Memoization**
上面的代码虽然可以执行，但是其效率并不高——重复的计算太多。基于Top-down简单地使用cache优化：

```py
cache = {}
def f(C, i):
    if (C, i) in cache:
        return cache[(C, i)]
    if i > 0:
        if w[i] > C:
            result = f(C, i - 1)
        else:
            result = max(f(C, i - 1), f(C - w[i], i - 1) + v[i])
    else:
        if w[i] > C:
            result = 0
        else:
            result = v[i]

    cache[(C, i)] = result
    return result
```

## 03：Bottom-up解决方案
**方案理由**
即便是上面这样子，basecase正确无误而且进行了速度优化的代码，仍然在提交代码测试的时候出现Runtime Error——这是因为递归调用栈溢出的问题。也就是说，不能使用递归的方式解决规模太大的问题；那么，就需要把递归解决方式转为迭代解决方式。
因为这个问题是二维的（C，i），所以可以声明一个二维数组，每个格子存储对应的`f(C, i)`问题的解，就自然不会出现重复计算。
但是，也正因为是这样子，要考虑计算的先后顺序。在01背包问题的状态转移方程中，很容易看出，每个问题都依赖于两个更小的子问题的解。

**初步解决**
以测试用例

```
4 5
1 8
2 4
3 0
2 5
2 3
```
为例。[原题目](https://vjudge.net/problem/SPOJ-KNAPSACK)

大致描述流程：
1. 初始化二维数组并赋值合适初始值
2. 使用两个嵌套循环完成问题求解。

***初始化数组`solve`***

首先，确定两个参数对应二维数组的顺序——应当是`solve[C][I]`（C、I为最大问题的参数），以（c，i）作为实际传入的参数。数组中的初始值应当是0，这样可以避免麻烦。

这里需要考虑的两点：
1. 背包的实际容量为0 ~ C，所以初始化第一维长度应当是C+1；
2. 为了i=0时计算简便，作出改变：初始化第二维长度为I+1，但是实际取值是1≤i≤I。

所以综合来看，
`0 ≤ c ≤ C`且`1 ≤ i ≤ I`。

***实现迭代求解***
根据状态转移方程的规则，每一个问题的子问题解，在这个问题（c，i）的上一列（第i-1列，c为行，i为列）。那么，循环应当以i的增加为序。

Bottom-up式的完整代码：

```py
solve = [[0 for j in range(I + 1)] for i in range(C + 1)]# 初始化数组
for c in range(C + 1):
    for i in range(1, I + 1):
        solve[c][i] = max(solve[c][i - 1], solve[c - w[i]][i - 1] + v[i]) if w[i] <= c else solve[c][i - 1]
print(solve[-1][-1])
```
特别注意：**遍历顺序（正序／倒序）**与**遍历次序（嵌套的内外顺序）**是有讲究的，本代码中的是（正序，先行后列），手动模拟可以发现，这个算法方式遵循了从左上角到右下角的顺序需求，也就能保障任何一个（子）问题不会依赖于尚未计算出的值了。

## 04：优化Bottom-up
这是最后一个环节。按照03的方式已经是比较优的解决方案，但是利用优化后的方法，还可以降低空间复杂度。
如果已经按照上一节最后的二维数组手动模拟，那么肯定对整个数组遍历次序很了解了。优化后的Bottom-up方案只使用一个一位数组即可解决问题。因为每个问题的两个子问题都处于上一列（i-1），而且都一定比该问题的行数小（<C），我们可以采取（逆序，先列后行）的顺序满足需求。
代码如下：
```py
solve = [0] * (S + 1)
for i in range(1, N+1):# 先列后行，因为数组存储的只是一个列
    for c in range(S, w[i] - 1, -1):
        solve[c] = max(solve[c], solve[c - w[i]] + v[i])# 直接覆盖掉更新
print(solve[-1])
```

至此，01背包问题整个解法已经十分优化了。
